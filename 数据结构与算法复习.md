**[有趣的学习网站-EN](http://www.cs.usfca.edu/~galles/visualization/Algorithms.html)**
* **二分查找算法**  
  二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；  
  其缺点是要求待查表为有序表，且插入删除困难。  
  因此，折半查找方法适用于不经常变动而查找频繁的有序列表 。  
  首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；  
  否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。  
  重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功

  源代码: 数据结构与算法复习/binary_search.rb  
  
* **杨辉三角**  
  前提：端点的数为1.  
  * 每个数等于它上方两数之和。  
  * 每行数字左右对称，由1开始逐渐变大。  
  * 第n行的数字有n项。  
  * 第n行数字和为2^(n-1)。  

  源代码：数据结构与算法复习/yanghuisanjiao.rb  

* [顺序表,链表,栈,队列](http://developer.51cto.com/art/201204/332798.htm)
* 树
* 图
* [排序](http://www.cnblogs.com/kkun/archive/2011/11/23/2260312.html)
 
  * 快速排序 <基准>
  * 插入排序 当插入第i个元素时，前面的i-1个元素已经排列好,用Vi依次去比较前面的i-1个元素,找到合适的位置插入
  * 选择排序 直接从待排序数组里选择一个最小(或最大)的数字,每次都拿一个最小数字出来,顺序放入新数组,直到全部拿完
  * 归并排序(Merge sort) 把原始数组分成若干子数组,对每一个子数组进行排序,继续把子数组与子数组合并,合并后仍然有序,直到全部合并完,形成有序的数组
  * 基数排序 <排序码>
  * 桶排序(Bucket sort) 无序数组有个要求,就是成员隶属于固定(有限的)的区间,
  * 冒泡排序(交换排序) <内循环><外循环> 临近的数字两两进行比较,按照从小到大或者从大到小的顺序进行交换
  * 希尔排序(Shell sort)  ??
* 搜索
